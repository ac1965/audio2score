#+title: audio2score: Audio → MIDI → MusicXML → PDF
#+author: YAMASHITA, Takao
#+language: ja
#+property: header-args :noweb no-export :mkdirp yes

* Overview

本プロジェクトは、 *1つの音源ファイル* から、以下のパイプラインを自動実行するための
Python ベースのツール群と Makefile を提供します。

1. 入力音源（WAV / m4a / mp3 / flac など）を ffmpeg で
   - mono
   - 44.1kHz
   - 正規化（ピーク合わせ）
   された WAV に変換する。
2. Demucs アンサンブル（複数モデル）でステム分離（vocals / drums / bass / other 等）。
3. BasicPitch によるメロディラインの推定（Audio → MIDI）。
4. MuseScore CLI による MIDI → MusicXML / PDF 変換。
5. 生成されたファイル（WAV / MIDI / MusicXML / PDF）を =build/= 以下に体系的に保存。

音源から楽譜（PDF）までの一連の処理を *再現可能な形* で実行することを目的としています。

* Repository Layout

本プロジェクトは、Org Babel の :tangle 機能によって
=README.org= からソースコードや設定ファイルを生成します。

- =README.org= から tangle されるファイル：
  - =pyproject.toml=      # パッケージメタデータ / 依存定義
  - =src/audio2score/=    # Python パッケージ本体
  - =Makefile=            # フルパイプライン用 Makefile（uv 前提）

ディレクトリ構成（想定）:

#+begin_src text
  .
  ├── README.org                 # 本ドキュメント（:tangle によりコードを生成）
  ├── pyproject.toml             # PEP 621 ベースのプロジェクト定義
  ├── src/
  │   └── audio2score/
  │       ├── __init__.py
  │       ├── preprocess.py        # 音声正規化（WAV mono / 44.1kHz）
  │       ├── demucs_engine.py     # Demucs アンサンブル呼び出し
  │       ├── basicpitch_engine.py # BasicPitch による Audio→MIDI
  │       ├── score_export.py      # MIDI → MusicXML / PDF Export
  │       ├── pipeline.py          # 全パイプライン制御
  │       └── cli.py               # コマンドラインエントリポイント
  ├── Makefile                     # uv ベースのフルパイプライン Makefile
  └── build/                       # 出力（WAV/MIDI/MusicXML/PDF）
#+end_src

* Requirements

本プロジェクトは、macOS を中心に、以下の条件を満たす環境で動作します。

** OS・Python

- macOS 13 Ventura / 14 Sonoma / 15 Sequoia / 16 Tahoe （Apple Silicon 推奨）
- Python 3.10 系
  - 詳細なセットアップ手順は *Setup* 章を参照してください。

** Required Applications

- ffmpeg  8.x
  - 入力音源を WAV（mono / 44.1kHz）へ統一するために必須
  - Homebrew インストール例：

#+begin_src bash
  brew install ffmpeg
#+end_src

- MuseScore
  - MuseScore 3 または MuseScore 4 のいずれか（CLI が利用可能であること）
  - macOS の場合の代表的なコマンド名：
    - MuseScore 3: =mscore=
    - MuseScore 4: =musescore4=

** Python Package Dependencies (PEP 621, managed via pyproject.toml)

本ツールは以下の Python ライブラリを利用します。すべて =uv sync= によって自動インストールされます。

| パッケージ        | 用途                                            |
|-------------------+--------------------------------------------------|
| librosa>=0.10     | 音声前処理（正規化、ロード、リサンプリング）    |
| soundfile>=0.12   | WAV の読み書き                                  |
| basic-pitch>=0.3  | メロディ推定（Audio→MIDI）                      |
| demucs>=4.0.0     | マルチモデル・アンサンブルによるステム分離      |
| music21>=9.1      | MIDI → MusicXML（MuseScore 失敗時の fallback）  |
| numpy>=1.23       | 基本演算                                        |
| scipy>=1.10       | 信号処理                                        |
| numba>=0.57       | librosa 速度最適化                              |
| tqdm>=4.66        | プログレスバー                                  |
| requests>=2.31    | モデルの自動ダウンロード（Demucs）             |
| torch>=2.1        | Demucs 実行用                                    |

** Demucs Models

Demucs では、以下のモデルをアンサンブルとして利用します。

- =htdemucs=
- =htdemucs_6s=

これらは *高精度ステム分離* のベーシックセットであり、本ツールの
=--models htdemucs htdemucs_6s= デフォルト設定に対応しています。

** uv ベースの Python 環境（推奨）

- 依存関係と仮想環境の管理には Rust 製 Python パッケージマネージャ *uv* を利用します。
- uv のインストール例（Homebrew）:

#+begin_src bash
  brew install uv
#+end_src

以降の具体的なセットアップ手順は次節 *Setup* で説明します。

* Setup

ここでは、uv を用いて Python 3.10 系の再現可能な環境を構築する手順を示します。

** 1. uv のインストール確認

すでに uv をインストール済みであればこのステップは省略できます。

#+begin_src bash
  uv --version
#+end_src

バージョンが表示されない場合は、例として Homebrew からインストールします。

#+begin_src bash
  brew install uv
#+end_src

** 2. Python 3.11 系の利用を明示（uv python pin）

プロジェクトルート（=README.org= や =pyproject.toml= があるディレクトリ）で実行します。

- Python 3.11 系
  - 本プロジェクトでは *uv* による Python / 仮想環境管理を前提とします。
  - =uv python pin 3.11= などで、このプロジェクトを Python 3.11.x に固定することを推奨します。

#+begin_src bash
  #  Python のリストを表示
  uv python version

  # プロジェクトで使用する Python を 3.11 系に固定
  uv python pin 3.11
#+end_src

これにより、.python-version に相当する情報が uv 側に記録され、
このディレクトリ配下では常に Python 3.11.x が使用されます。

** 3. 依存関係の同期（uv sync）

=pyproject.toml= の依存関係定義にもとづいて、仮想環境（=.venv=）と
ロックファイル（=uv.lock=）を作成します。

#+begin_src bash
  # プロジェクトルートで実行
  uv sync
#+end_src

実行後、以下が生成されます。

- =.venv/=     … uv 管理の仮想環境
- =uv.lock=    … 依存関係のバージョンを固定したロックファイル

** 4. 外部コマンド（ffmpeg / MuseScore）の確認

#+begin_src bash
  ffmpeg -version

  # MuseScore 3 利用時
  mscore --help

  # MuseScore 4 利用時
  musescore4 --help
#+end_src

それぞれがエラーなくヘルプやバージョン情報を表示すれば OK です。

** 5. 初回のパイプライン実行

あらかじめ、任意の音源ファイル（例：=env/input/foo.m4a=）を用意します。

#+begin_src bash
  # 依存関係が未同期の場合は先に uv sync を実施
  uv sync

  # Makefile を利用したフルパイプライン実行例
  make score INPUT="env/input/foo.m4a"
#+end_src

初回実行時は、Demucs のモデル（=htdemucs=, =htdemucs_6s=）が自動ダウンロードされるため、
ネットワーク環境とストレージの空き容量をあらかじめ確保してください。

* Usage

** Makefile 経由で実行

#+begin_src sh
  # WAV 変換 + パイプライン実行（uv + Makefile 前提）
  make score INPUT="env/input/foo.m4a"

  # STEM 無しで main MIDI のみ（将来の拡張用の例）
  make score INPUT="env/input/foo.wav" STEMS=0
#+end_src

** uv run から直接 CLI を叩く例

=make score= は内部で =uv run -- python -m audio2score.cli ...= を呼び出します。
Makefile を介さず直接実行したい場合は、以下のようにします。

#+begin_src bash
  uv run -- python -m audio2score.cli \
    "build/foo.wav" \
    --output-dir "build" \
    --stems \
    --models htdemucs htdemucs_6s \
    --musescore-cmd mscore
#+end_src

* pyproject.toml

#+begin_src toml :tangle pyproject.toml
  [project]
  name = "audio2score"
  version = "0.1.0"
  description = "Audio → MIDI → MusicXML → PDF pipeline using Demucs ensemble + BasicPitch."
  # Python 3.11 系で固定
  requires-python = ">=3.11,<3.12"
  authors = [
    { name = "YAMASHITA, Takao" }
  ]
  license = { text = "MIT" }

  # -------------------------------------------
  # Runtime Dependencies (本番動作に必要)
  # -------------------------------------------
  dependencies = [
    "librosa>=0.10",          # 音声前処理（正規化、ロード、リサンプリング）
    "soundfile>=0.12",        # WAV の読み書き
    "basic-pitch>=0.3",       # Audio → MIDI（Py3.11 対応）
    "demucs>=4.0.0",          # ステム分離
    "music21>=9.1",           # MIDI → MusicXML 等
    "numpy>=1.23",            # 数値演算
    "scipy>=1.10",            # 信号処理
    "numba>=0.57",            # librosa 用の高速化
    "tqdm>=4.66",             # プログレスバー
    "requests>=2.31",         # モデル取得など HTTP

    # TorchCodec を避ける
    "torch==2.7.*",           # PyTorch 2.7 系（torchaudio 2.7 とセット）
    "torchaudio==2.7.*",      # TorchAudio 2.7 系（この版では save/load は従来 backend）

    # pkg_resources を提供しつつ、将来削除を避ける
    "setuptools>=68,<81",     # resampy / basic-pitch 用
  ]

  # -------------------------------------------
  # Optional / Dev Dependencies
  # -------------------------------------------
  [project.optional-dependencies]
  dev = [
    "pytest>=8.3",
    "black>=24.4",
    "ruff>=0.6",
  ]

  [project.urls]
  homepage   = "https://github.com/ac1965/audio2score"
  repository = "https://github.com/ac1965/audio2score"

  [build-system]
  requires = ["setuptools>=68"]
  build-backend = "setuptools.build_meta"

  [tool.audio2score]
  default_models     = ["htdemucs", "htdemucs_6s"]
  default_samplerate = 44100
#+end_src

* Python Source Files

** preprocess.py

#+begin_src python :tangle src/audio2score/preprocess.py
  #!/usr/bin/env python3
  import pathlib
  import numpy as np
  import soundfile as sf
  import librosa


  def normalize_audio(input_path: pathlib.Path, sr: int = 44100) -> pathlib.Path:
      """
      WAV を読み込み:
      - モノラル変換
      - サンプリングレート統一
      - 振幅正規化（peak=0.95）
      """
      y, orig_sr = librosa.load(str(input_path), sr=sr, mono=True)
      if y.size == 0:
          raise ValueError(f"Input audio is empty: {input_path}")

      peak = np.max(np.abs(y))
      if peak > 0:
          y = 0.95 * y / peak

      out_path = input_path.with_suffix(".norm.wav")
      sf.write(out_path, y, sr)
      return out_path
#+end_src

** demucs_engine.py

#+begin_src python :tangle src/audio2score/demucs_engine.py
  #!/usr/bin/env python3
  import pathlib
  import subprocess
  from typing import List


  def separate_stems(
      audio: pathlib.Path,
      models: List[str],
      output_root: pathlib.Path,
  ) -> pathlib.Path:
      """
      Demucs を使ってステム分離を行う。
      - models: ["htdemucs", "htdemucs_6s"] など
      - output_root/stems/{model}/ 以下に各ステムを保存
      """
      audio = audio.resolve()
      stems_dir = output_root / "stems"
      stems_dir.mkdir(parents=True, exist_ok=True)

      for model in models:
          model_out = stems_dir / model
          model_out.mkdir(parents=True, exist_ok=True)

          cmd = [
              "demucs",
              "-n",
              model,
              "-o",
              str(model_out),
              str(audio),
          ]

          print(f"[Demucs] Running: {' '.join(cmd)}")
          subprocess.run(cmd, check=True)

      return stems_dir
#+end_src

** basicpitch_engine.py

#+begin_src python :tangle src/audio2score/basicpitch_engine.py
  #!/usr/bin/env python3
  import pathlib
  from typing import Tuple

  import numpy as np
  from basic_pitch.inference import predict_and_save
  from basic_pitch import ICASSP_2022_MODEL_PATH


  def run_basic_pitch(
      audio: pathlib.Path,
      output_root: pathlib.Path,
      stem_name: str,
  ) -> Tuple[pathlib.Path, pathlib.Path]:
      """
      BasicPitch による Audio→MIDI 変換。
      - 既存の .mid / .npz / .csv があれば自動削除してから再生成
      - 入力ファイル名（stem_name）を最終成果物まで保持
      """
      audio = audio.resolve()
      midi_dir = output_root / "midi"
      midi_dir.mkdir(parents=True, exist_ok=True)

      print(f"[BasicPitch] audio={audio}")

      # --- ★ 既存出力の自動クリーン（BasicPitch の安全停止対策） ---
      for ext in ("*.mid", "*.npz", "*.csv"):
          for f in midi_dir.glob(ext):
              f.unlink()

      # --- Basic Pitch v0.4.x 正式API ---
      predict_and_save(
          [str(audio)],           # input_audio_path_list
          str(midi_dir),          # output_directory
          True,                   # save_midi
          False,                  # sonify_midi
          True,                   # save_model_outputs
          True,                   # save_notes
          ICASSP_2022_MODEL_PATH, # 使用モデル
      )

      # --- MIDI ファイル取得 ---
      mids = sorted(midi_dir.glob("*.mid"))
      if not mids:
          raise FileNotFoundError(f"No MIDI file generated in {midi_dir}")

      final_midi = midi_dir / f"{stem_name}.mid"
      if final_midi.exists():
          final_midi.unlink()
      mids[0].rename(final_midi)

      # --- npz ファイル取得 ---
      npzs = sorted(midi_dir.glob("*.npz"))
      if npzs:
          onnx_path = npzs[0]
      else:
          onnx_path = midi_dir / f"{stem_name}.npz"
          np.save(onnx_path, np.zeros((1,)))

      print(f"[BasicPitch] MIDI generated: {final_midi}")

      return final_midi, onnx_path
#+end_src

** score_export.py

#+begin_src python :tangle src/audio2score/score_export.py
  #!/usr/bin/env python3
  import pathlib  # ← ★ これが抜けていた
  import subprocess


  def export_score_with_musescore(
      midi_path: pathlib.Path,
      output_root: pathlib.Path,
      stem_name: str,
      musescore_cmd: str = "musescore4",
      no_pdf: bool = False,
  ) -> pathlib.Path:
      """
      MuseScore CLI を用いて
      - MIDI → MusicXML
      - MusicXML → PDF
      を行う（入力ファイル名を保持）
      """
      midi_path = midi_path.resolve()
      score_dir = output_root / "score"
      score_dir.mkdir(parents=True, exist_ok=True)

      musicxml_path = score_dir / f"{stem_name}.musicxml"
      pdf_path = score_dir / f"{stem_name}.pdf"

      # --- MIDI -> MusicXML ---
      cmd_xml = [
          musescore_cmd,
          "-o",
          str(musicxml_path),
          str(midi_path),
      ]

      print(f"[MuseScore] MIDI → MusicXML: {' '.join(cmd_xml)}")
      subprocess.run(cmd_xml, check=True)

      if no_pdf:
          return musicxml_path

      # --- MusicXML -> PDF ---
      cmd_pdf = [
          musescore_cmd,
          "-o",
          str(pdf_path),
          str(musicxml_path),
      ]

      print(f"[MuseScore] MusicXML → PDF: {' '.join(cmd_pdf)}")
      subprocess.run(cmd_pdf, check=True)

      return musicxml_path
#+end_src

** pipeline.py

#+begin_src python :tangle src/audio2score/pipeline.py
  #!/usr/bin/env python3
  import pathlib  # ← ★ これが抜けていた
  from dataclasses import dataclass
  from typing import List, Optional

  from .preprocess import normalize_audio
  from .demucs_engine import separate_stems
  from .basicpitch_engine import run_basic_pitch
  from .score_export import export_score_with_musescore


  @dataclass
  class PipelineResult:
      raw_wav: pathlib.Path
      normalized_wav: pathlib.Path
      stems_dir: pathlib.Path
      midi_path: pathlib.Path
      musicxml_path: pathlib.Path
      pdf_path: Optional[pathlib.Path]


  def run_pipeline(
      audio: pathlib.Path,
      output_root: pathlib.Path,
      do_stems: bool = True,
      models: Optional[List[str]] = None,
      musescore_cmd: str = "musescore4",
      no_pdf: bool = False,
  ) -> PipelineResult:

      audio = audio.resolve()
      output_root.mkdir(parents=True, exist_ok=True)

      stem_name = audio.stem

      print(f"[Pipeline] Input: {audio}")

      # 1. 正規化
      normalized = normalize_audio(audio)

      # 2. Demucs ステム分離
      stems_dir = output_root / "stems"
      if do_stems:
          if models is None:
              models = ["htdemucs", "htdemucs_6s"]
          stems_dir = separate_stems(normalized, models, output_root)
      else:
          stems_dir.mkdir(parents=True, exist_ok=True)

      # 3. BasicPitch（入力名を保持）
      midi_path, _onnx_path = run_basic_pitch(
          normalized,
          output_root,
          stem_name=stem_name,
      )

      # 4. MuseScore（入力名を保持）
      musicxml_path = export_score_with_musescore(
          midi_path=midi_path,
          output_root=output_root,
          stem_name=stem_name,
          musescore_cmd=musescore_cmd,
          no_pdf=no_pdf,
      )

      pdf_path = output_root / "score" / f"{stem_name}.pdf"
      if no_pdf or not pdf_path.exists():
          pdf_path = None

      return PipelineResult(
          raw_wav=audio,
          normalized_wav=normalized,
          stems_dir=stems_dir,
          midi_path=midi_path,
          musicxml_path=musicxml_path,
          pdf_path=pdf_path,
      )
#+end_src

** cli.py

#+begin_src python :tangle src/audio2score/cli.py
  #!/usr/bin/env python3
  import argparse
  import pathlib
  import sys

  from .pipeline import run_pipeline


  def main() -> int:
      parser = argparse.ArgumentParser("audio2score CLI")

      parser.add_argument("audio", help="Input WAV (or converted WAV)")
      parser.add_argument(
          "--output-dir",
          default="build",
          help="Output root directory (default: build)",
      )
      parser.add_argument(
          "--stems",
          action="store_true",
          help="Run Demucs stem separation",
      )
      parser.add_argument(
          "--models",
          nargs="*",
          default=["htdemucs", "htdemucs_6s"],
          help="Demucs model names (default: htdemucs htdemucs_6s)",
      )
      parser.add_argument(
          "--musescore-cmd",
          default="mscore",
          help="MuseScore CLI command (mscore or musescore4)",
      )
      parser.add_argument(
          "--no-pdf",
          action="store_true",
          help="Do not export PDF (MusicXML only)",
      )

      args = parser.parse_args()

      audio = pathlib.Path(args.audio).resolve()
      out = pathlib.Path(args.output_dir).resolve()

      result = run_pipeline(
          audio=audio,
          output_root=out,
          do_stems=args.stems,
          models=args.models,
          musescore_cmd=args.musescore_cmd,
          no_pdf=args.no_pdf,
      )

      print("=== DONE ===")
      print(result)
      return 0


  if __name__ == "__main__":
      sys.exit(main())
#+end_src

* Makefile

#+begin_src makefile :tangle Makefile
  # ============================================================
  # Audio2Score Full Pipeline Makefile (uv-based, Python 3.11)
  # ============================================================

  SHELL := /bin/bash

  # ------------------------------------------------------------
  # Tools
  # ------------------------------------------------------------
  UV := uv

  # ------------------------------------------------------------
  # Input / Output
  # ------------------------------------------------------------
  # 入力ファイル（拡張子は何でも可：m4a, mp3, flac, wav ...）
  INPUT ?= input.wav

  # ベース名だけ取り出し（拡張子なし）
  NAME := $(notdir $(basename $(INPUT)))

  # 出力ルートディレクトリ
  BUILD_DIR := build

  # ffmpeg で変換後の WAV（パイプライン入口）
  RAW_WAV := $(BUILD_DIR)/$(NAME).wav

  # ============================================================
  # Main targets
  # ============================================================
  .PHONY: all
  all: score

  # ------------------------------------------------------------
  # 1. Create / sync uv-managed environment
  #    - プロジェクト単位で Python 3.11 を pin してから uv sync
  # ------------------------------------------------------------
  .PHONY: setup
  setup:
  	@echo ">>> Pinning Python 3.11 for this project"
  	$(UV) python pin 3.11
  	@echo ">>> Syncing uv environment (.venv / uv.lock)"
  	$(UV) sync

  # ------------------------------------------------------------
  # 2. Convert INPUT → WAV with ffmpeg (mono / 44.1kHz)
  # ------------------------------------------------------------
  .PHONY: ffmpeg
  ffmpeg: $(RAW_WAV)

  $(RAW_WAV):
  	@mkdir -p $(BUILD_DIR)
  	@echo "[FFMPEG] Converting $(INPUT) → $@ (mono, 44.1kHz)"
  	ffmpeg -y -i "$(INPUT)" -ac 1 -ar 44100 "$@"

  # ------------------------------------------------------------
  # 3. Run audio2score pipeline (Demucs + BasicPitch + MuseScore)
  # ------------------------------------------------------------
  .PHONY: score
  score: setup ffmpeg
  	@echo "=== Running audio2score pipeline via uv run ==="
  	$(UV) run -- python -m audio2score.cli \
  		"$(RAW_WAV)" \
  		--output-dir "$(BUILD_DIR)" \
  		--stems \
  		--models htdemucs htdemucs_6s \
  		--musescore-cmd mscore

  # ------------------------------------------------------------
  # Clean up
  # ------------------------------------------------------------
  .PHONY: clean
  clean:
  	rm -rf $(BUILD_DIR)

  .PHONY: clean-venv
  clean-venv:
  	rm -rf .venv uv.lock

  .PHONY: distclean
  distclean: clean clean-venv
  	rm -rf src/audio2score/*.pyc __pycache__
#+end_src

* 命名規則

本プロジェクトでは、*入力ファイル（INPUT）で指定した音源のベースファイル名を、パイプラインの最終成果物（PDF）まで一貫して保持* する。

** 命名規則の基本方針

- INPUT で指定された音源ファイルの *拡張子を除いたベース名* を、以降のすべての成果物のファイル名に使用する。
- 処理の途中で *main.mid* や *main.pdf* のような固定名には *変換しない*。
- 同一ディレクトリ内で複数ファイルを処理した場合でも、*上書きが発生しない* 安全な命名規則となっている。

** 具体例

以下の入力を例とする：

#+begin_src text
INPUT = env/input/おはよう.wav
#+end_src

この場合、生成される成果物はすべて以下の命名となる。

| 処理段階              | 出力先ディレクトリ | ファイル名                    |
|-----------------------+---------------------+--------------------------------|
| ffmpeg 変換           | build/              | おはよう.wav                   |
| 正規化（preprocess） | build/              | おはよう.norm.wav              |
| BasicPitch（MIDI）    | build/midi/         | おはよう.mid                   |
| 楽譜（MusicXML）     | build/score/        | おはよう.musicxml              |
| 楽譜（PDF）          | build/score/        | おはよう.pdf                   |

** 複数ファイル処理時の安全性

- すべての成果物は *INPUT のベース名ごとに分離* されるため、以下のような連続処理でも成果物が衝突しない。

#+begin_src bash
make score INPUT="env/input/song_a.wav"
make score INPUT="env/input/song_b.wav"
#+end_src

このとき、生成される成果物は以下のように共存する。

#+begin_src text
build/midi/song_a.mid
build/midi/song_b.mid
build/score/song_a.pdf
build/score/song_b.pdf
#+end_src

** 設計上の意図

- ファイル管理を *人間が目視で追跡可能* にすることを最優先とする。
- バッチ処理・連続処理・スクリプト連携において、*成果物の対応関係が常に一意に復元できる* ことを保証する。
- 研究用途・採譜用途・業務用途いずれにおいても、*成果物の真正性（どの音源から生成されたか）をファイル名だけで判別できる* 状態を維持する。
